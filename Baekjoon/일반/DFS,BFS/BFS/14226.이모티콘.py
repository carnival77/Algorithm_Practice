# 풀이
# 1. 행동 3가지 모두 1초씩 소요되므로 BFS 로 풀이 가능
# 2. 2번 행동(붙여넣기) 할 때 최대 범위를 목표인 n으로 하면, 그 이하 범위에서 탐색하기에 더 빠르다.
# 3. 여기서는 check, dist 두 개 대신 dist 하나만 쓴다. dist[s][c]로 표현하여, dist[s][c] == -1이면 방문하지 않은 것이다.
# @설명
#   : 모든 간선의 가중치가 1인 BFS를 활용해 최단 시간 혹은 최단 거리를 찾을 때는,
#       한 번 찾은 최단 거리는 갱신되지 않는다.
#       따라서 여기서 목표를 찾았을 때 현재 상태까지 걸린 시간이 최소 시간이다.
import sys
from collections import deque

input = sys.stdin.readline

n=int(input())

ans=0
MAX = 2000
dist=[[-1]*(MAX) for _ in range(MAX)]
# @ 따라서, MAX가 아닌 주어진 목표 수 만큼의 배열만 만들어도 된다.
# dist=[[-1]*(n+1) for _ in range(n+1)]
dist[1][0]=0

q=deque()

q.append((1,0))
while q:
    s,c = q.popleft() # s,c = 현재 상태의 화면과 클립보드에 있는 이모티콘의 개수

    # 1) BFS 원리에 따른 답.
    # 설명
    #   : 모든 간선의 가중치가 1인 BFS를 활용해 최단 시간 혹은 최단 거리를 찾을 때는,
    #       한 번 찾은 최단 거리는 갱신되지 않는다.
    #       따라서 여기서 목표를 찾았을 때 현재 상태까지 걸린 시간이 최소 시간이다.
    if s==n:
        ans=dist[s][c]
        print(ans)
        sys.exit(0)

    # (1) 화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다. + (3) 화면에 있는 이모티콘 중 하나를 삭제한다.
    # 조건 1은, 화면에 이모티콘이 1개 이상 있는 것이다. 그렇지 않다면 화면과 클립보드 모두 0개가 되어 목표를 달성 못 한다.
    # 조건 2은, 화면에 있는 이모티콘의 개수가 최대치인 2000을 넘기면 안 된다. 넘기면 -1로 돌아가기에 비효율적이기에 탐색 범위를 제한
    # if s>0 and s<MAX:
    # @ 따라서, 화면의 이모티콘 개수가 목표 개수보다 크지만 않으면 된다. 크면 어차피 최단 시간 못 찾는다.
    if s > 0 and s <= n:
        # (1)의 조건 2은, 화면에 있는 이모티콘의 개수와 클립보드에 있는 이모티콘의 개수가 동일할 때이다. (dist[s][s] == -1)
        if dist[s][s] == -1:
            dist[s][s] = dist[s][c] + 1 # "화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다." 라는 행동은 현재 상태인 dist[s][c]에서 1초짜리 행동을 행한 결과다.
            q.append((s,s)) # 행동이 취해진 결과인 [s,s] 를 큐에 넣는다.
        # (3) 화면에 있는 이모티콘 중 하나를 삭제한다.
        if dist[s-1][c] == -1:
            dist[s-1][c] = dist[s][c] +1
            q.append((s-1,c))
    # 2. 클립보드에 있는 모든 이모티콘을 화면에 붙여넣기한다.
    # 조건 1은, 클립보드에 1개 이상의 이모티콘이 있어야 한다. 그렇지 않다면 화면과 클립보드 모두 0개가 되어 목표를 달성 못 한다.
    # 조건 2은, 화면과 클립보드에 있는 이모티콘의 합의 개수가 최대치인 2000을 넘기면 안 된다. 넘기면 -1로 돌아가기에 비효율적이기에 탐색 범위를 제한
    # if c>0 and s+c < MAX:
    # @ 따라서, 화면 + 클립보드의 이모티콘 개수가 목표 개수보다 크지만 않으면 된다. 크면 어차피 최단 시간 못 찾는다.
    if c > 0 and s + c <= n:
        if dist[s+c][c] == -1:
            dist[s+c][c] = dist[s][c] +1
            q.append((s+c,c))

# # 2) 백준식 답
# ans=-1
# # dist[n] 은 2000개 크기의 배열이다. 이 중 클립보드에 몇 개가 있든 dist[s][c]가 최솟값인 것이 답이다.
# for i in range(n+1):
#     if dist[n][i] != -1:
#         if ans == -1 or ans > dist[n][i]:
#             ans = dist[n][i]
# print(ans)