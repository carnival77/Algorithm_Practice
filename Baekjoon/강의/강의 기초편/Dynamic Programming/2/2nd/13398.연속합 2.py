n=int(input())
a=list(map(int,input().split()))

#solution 1.
d1=a # 수열 a의 각 인덱스까지의 최대 연속합을 담는다. d1[i] : i번째 수에서 끝나는 최대 연속합
d2=a[::-1] # 수열 a의 각 인덱스부터의 최대 연속합을 담는다. d2[i] : i번째 수에서 시작하는 최대 연속합
# i번째 수를 제거하면 i-1번째 수와 i+1번째 수가 연속하게 된다.
# 따라서, d1[i-1] + d2[i+1] 이 i번째 수를 제거했을 때의 최대 연속합이 된다.

for i in range(1,n):
    d1[i]=max(d1[i],d1[i-1]+d1[i])
    d2[i]=max(d2[i],d2[i-1]+d2[i])
d2.reverse()
ans=max(d1) # 여기서 인덱스 0,n-1번째도 고려한 최대 연속합이 구해진다.
for i in range(1,n-1): # 따라서 0,n-1번째를 여기서 고려할 필요가 없다.
    ans=max(ans,d1[i-1]+d2[i+1])

print(ans)

# solution 2.
d=[[0]*2 for _ in range(n)]
# d[i][0] : i번째까지 특정 원소를 안 지웠을 때의 최대 연속합
# d[i][1] : i번째까지 특정 원소를 지웠을 때의 최대 연속합
d[0][0]=a[0] # 최소 1개 이상의 수를 선택한다.
ans=-int(1e9)
for i in range(1,n):
    # 아무런 원소를 제거하지 않았을 때, (이전까지의 연속합 + i번쨰 원소) 와 (i번째 원소)를 비교하여 큰 경우를 대입
    d[i][0]=max(a[i],d[i-1][0]+a[i])
    # 특정 원소를 제거하는 경우 =>
    # 1. i번째 원소를 제거하는 경우 : d[0][i - 1]
    # 2. i번째 이전에서 이미 특정 원소를 제거하여 i번째 원소를 선택하는 경우 : d[1][i-1] + arr[i]
    d[i][1]=max(d[i-1][0],d[i-1][1]+a[i])
    ans=max(ans,d[i][0],d[i][1])
if n==1:
    print(d[0][0])
else:
    print(ans)