좋아. “이분 매칭”을 처음 듣는 사람 기준으로, 이 문제를 **쉽게** 풀어보자.

# 문제를 가장 쉬운 말로 풀면

* 인덱스별로 A[i] 또는 B[i] 중 **딱 하나**를 골라서 C[i]를 만든다.
* C 안에 **없는 가장 작은 양의 정수(MEX)** 를 **가능한 한 작게** 만들고 싶다.
* 어떤 수 `m`이 MEX가 되려면:

  1. `1,2,…,m-1` 은 **반드시** C에 최소 한 번씩 존재
  2. `m` 은 **한 번도 나오면 안 됨**

따라서 우리는 `m=1,2,3,…` 순서로 **“m이 MEX가 될 수 있나?”** 를 검사하고,
처음으로 가능한 `m`을 답으로 내면 된다.

# “이분 매칭”을 직관으로 이해하기

> 비유: **일(숫자)과 사람(인덱스) 배정 문제**

* 왼쪽 집합: **해야 할 일** = 숫자 `1..m-1` (각 숫자를 C에 한 번씩 넣어야 함)
* 오른쪽 집합: **사람** = 인덱스 `0..N-1`
* “간선(연결)”이 있다는 건 **그 인덱스에서 그 숫자를 고를 수 있다**는 뜻
  (즉 `A[i]==x` 또는 `B[i]==x`)
* 목표: **서로 다른 인덱스**에 `1..m-1`을 **모두** 배정할 수 있는가?

이게 바로 **최대 매칭**이다.
모든 숫자(1..m-1)가 각각 한 사람(인덱스)을 배정받으면 OK.
한 사람에게 일을 두 개 시킬 수는 없으니, 겹치면 안 된다.

그리고 **m을 절대 고르면 안 되므로**,
어떤 인덱스에서 `A[i]=m` **이면서** `B[i]=m` 이라면 그 인덱스는 **무조건 m**을 고를 수밖에 없다.
그런 인덱스가 하나라도 있으면 **m을 MEX로 만드는 건 불가능**이다(전역에서 m이 등장해버리니까).

# 절차 요약(한 후보 m에 대하여)

1. **강제 m 검사**:
   `A[i]=m` **and** `B[i]=m` 인 i가 있으면 → 이 m은 불가능

2. **존재성 검사**:
   `x ∈ [1..m-1]` 중 **어떤 x도** 어느 인덱스에서도 만들 수 없다면 → 이미 **MEX = x**

3. **최대 매칭**으로 `1..m-1`을 **서로 다른 인덱스**에 배정할 수 있으면 → **정답 = m**
   못 하면 다음 m으로 진행

> m은 최대 **N+1** 까지만 보면 된다(길이가 N이므로 1..N을 전부 넣어도 다음 수는 N+1).

# 파이썬 풀이 (next, lambda **미사용**)

```python
from collections import defaultdict

def solution(A, B):
    n = len(A)

    # 값 x -> x를 선택할 수 있는 인덱스들의 목록
    pos = defaultdict(list)
    for i in range(n):
        x, y = A[i], B[i]
        if x > 0:
            pos[x].append(i)
        if y > 0 and y != x:
            pos[y].append(i)

    # 강제 m 존재 여부: 어떤 i에서 (A[i]==m and B[i]==m)
    def has_forced_m(m):
        for i in range(n):
            if A[i] == m and B[i] == m:
                return True
        return False

    # 이분 매칭: 왼쪽(숫자 x) -> 오른쪽(인덱스 i)
    # matchR[i] = 이 인덱스 i에 매칭된 숫자 x (없으면 -1)
    def can_cover_all_upto(m):
        matchR = [-1] * n

        # DFS로 증대 경로 탐색 (Kuhn 알고리즘)
        def dfs(x, seen):
            if x not in pos:
                return False
            for i in pos[x]:
                if seen[i]:
                    continue
                seen[i] = True
                if matchR[i] == -1 or dfs(matchR[i], seen):
                    matchR[i] = x
                    return True
            return False

        for x in range(1, m):
            # 각 x를 배정하기 위한 방문배열 초기화
            seen = [False] * n
            if not dfs(x, seen):
                return False
        return True

    # m은 1..N+1 범위에서만 보면 충분
    m = 1
    while m <= n + 1:
        # 1) 강제 m이 있으면 이 m은 절대 불가
        if has_forced_m(m):
            m += 1
            continue

        # 2) 존재성 검사: 1..m-1 중 pos[x]가 비면 MEX는 그 x
        missing_x = 0
        for x in range(1, m):
            if x not in pos or len(pos[x]) == 0:
                missing_x = x
                break
        if missing_x != 0:
            return missing_x

        # 3) 최대 매칭으로 1..m-1 모두 커버 가능?
        if can_cover_all_upto(m):
            return m

        m += 1

    # 이론상 도달하지 않음(반드시 1..N+1에서 결정)
    return n + 2
```

### 복잡도

* 평균적으로 m이 작게 멈추어 충분히 빠르다.
* 최악은 매칭 부분이 커질 수 있으나, 필요하면 Hopcroft–Karp로 바꾸어 `O(√V · E)`까지 개선 가능.

---

## 한 줄 정리

* **이 문제는 “수(1..m-1)를 서로 다른 인덱스에 배정”하는 배정(매칭) 문제다.**
* **강제 m**만 없으면, 매칭이 성립하는 **가장 작은 m**이 곧 정답 MEX다.

**Q1.** pos를 구성할 때 음수나 0은 왜 빼도 되는가?

**Q2.** 같은 값이 매우 많이 반복될 때(예: 값 1이 수천 번), 매칭의 성능을 어떻게 개선할 수 있나?

**Q3.** Hopcroft–Karp로 바꿀 때 자료구조와 함수 인터페이스를 어떻게 조정하면 좋을까?
